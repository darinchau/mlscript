:NewDefs

// This is used internally to process stuff
class Builtin_Some__(depth: Int)
module Builtin_None__
type Builtin_Opts__[A] = Builtin_None__ | Builtin_Some__ | A & Object & ~Builtin_None__ & ~Builtin_Some__
fun __builtin_some(x) = if x is
  Builtin_None__ then Builtin_Some__(1)
  Builtin_Some__(d) then Builtin_Some__(d + 1)
  _ then x
fun __builtin_some_unapply(x) = if x is
  Builtin_Some__(1) then None
  Builtin_Some__(d) then Some(__builtin_some_unapply(Builtin_Some__(d - 1)))
  Builtin_None__ then None
  _ then x
//│ class Builtin_Some__(depth: Int)
//│ module Builtin_None__
//│ type Builtin_Opts__[A] = Builtin_None__ | Builtin_Some__ | Object & A & ~Builtin_None__ & ~Builtin_Some__
//│ fun __builtin_some: forall 'a. (Builtin_None__ | Builtin_Some__ | Object & 'a & ~#Builtin_None__ & ~#Builtin_Some__) -> (Builtin_Some__ | 'a)
//│ fun __builtin_some_unapply: forall 'b. (Builtin_None__ | Builtin_Some__ | Object & 'b & ~#Builtin_None__ & ~#Builtin_Some__) -> (None | 'b)
//│ where
//│   'b :> Some[None | 'b]


// This is exposed to the user
class Some[out A](val x: A)
module None
type Option[A] = Some[A] | None
//│ class Some[A](x: A)
//│ module None
//│ type Option[A] = None | Some[A]

:js
:p
let x = Some(1) 
//│ |#let| |x| |#=| |Some|(|1|)| |
//│ AST: TypingUnit(List(NuFunDef(Some(false),Var(x),None,List(),Left(App(Var(Some),Tup(List((None,Fld(_,IntLit(1))))))))))
//│ Parsed: let x = Some(1,);
//│ let x: Some[1]
//│ // Prelude
//│ class TypingUnit2 {}
//│ const typing_unit2 = new TypingUnit2;
//│ // Query 1
//│ globalThis.x = __builtin_some(1);
//│ // End of generated code
//│ x
//│   = 1

:js
:p
let y = None 
//│ |#let| |y| |#=| |None| |
//│ AST: TypingUnit(List(NuFunDef(Some(false),Var(y),None,List(),Left(Var(None)))))
//│ Parsed: let y = None;
//│ let y: None
//│ // Prelude
//│ class TypingUnit3 {}
//│ const typing_unit3 = new TypingUnit3;
//│ // Query 1
//│ globalThis.y = None;
//│ // End of generated code
//│ y
//│   = None { class: [class None] }

:js
let z = Some(None)
//│ let z: Some[None]
//│ // Prelude
//│ class TypingUnit4 {}
//│ const typing_unit4 = new TypingUnit4;
//│ // Query 1
//│ globalThis.z = __builtin_some(None);
//│ // End of generated code
//│ z
//│   = None { class: [class None] }

// That means its like
// case Some => let y = Some.unapply(x); 1
:js
fun f: Option['a] -> Int
fun f(x) = if x is
  Some(y) then 1 
  None then 2
  _ then 3
//│ fun f: (Object & ~#Some | Some[anything]) -> (1 | 2 | 3)
//│ fun f: forall 'a. Option['a] -> Int
//│ // Prelude
//│ class TypingUnit5 {}
//│ const typing_unit5 = new TypingUnit5;
//│ // Query 1 is empty
//│ // Query 2
//│ globalThis.f = function f(x) {
//│   let a;
//│   return a = x, a instanceof Builtin_Some__.class ? ((ucs$args_x$Some) => ((y) => 1)(ucs$args_x$Some[0]))(__builtin_some_unapply(x)) : a instanceof None.class ? 2 : 3;
//│ };
//│ // End of generated code

:js
f(Some(1))
//│ Int
//│ // Prelude
//│ class TypingUnit6 {}
//│ const typing_unit6 = new TypingUnit6;
//│ // Query 1
//│ res = f(__builtin_some(1));
//│ // End of generated code
//│ res
//│     = 3

:js
f(None)
//│ Int
//│ // Prelude
//│ class TypingUnit7 {}
//│ const typing_unit7 = new TypingUnit7;
//│ // Query 1
//│ res = f(None);
//│ // End of generated code
//│ res
//│     = 2
